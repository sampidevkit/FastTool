#ifndef USER_USB_DESCRIPTORS_C
#define USER_USB_DESCRIPTORS_C

/** INCLUDES *******************************************************/
#include "libcomp.h"

/** CONSTANTS ******************************************************/
#if defined(__18CXX)
#pragma romdata
#endif

/* Device Descriptor */
const USB_DEVICE_DESCRIPTOR device_dsc={
    0x12, // Size of this descriptor in bytes
    USB_DESCRIPTOR_DEVICE, // DEVICE descriptor type
    0x0200, // USB Spec Release Number in BCD format
    CDC_DEVICE, // Class Code
    0x00, // Subclass code
    0x00, // Protocol code
    USB_EP0_BUFF_SIZE, // Max packet size for EP0, see usb_device_config.h
    0x04D8, // Vendor ID
    0x000A, // Product ID
    0x0100, // Device release number in BCD format
    0x01, // Manufacturer string index
    0x02, // Product string index
    0x00, // Device serial number string index
    0x01 // Number of possible configurations
};

/* Configuration 1 Descriptor */
const uint8_t configDescriptor1[]={
    /* Configuration Descriptor */
    0x09, //sizeof(USB_CFG_DSC),    // Size of this descriptor in bytes
    USB_DESCRIPTOR_CONFIGURATION, // CONFIGURATION descriptor type
    67, 0, // Total length of data for this cfg
    2, // Number of interfaces in this cfg
    1, // Index value of this configuration
    0, // Configuration string index
    _DEFAULT|_SELF, // Attributes, see usb_device.h
    50, // Max power consumption (2X mA)

    /* Interface Descriptor */
    9, //sizeof(USB_INTF_DSC),   // Size of this descriptor in bytes
    USB_DESCRIPTOR_INTERFACE, // INTERFACE descriptor type
    0, // Interface Number
    0, // Alternate Setting Number
    1, // Number of endpoints in this intf
    COMM_INTF, // Class code
    ABSTRACT_CONTROL_MODEL, // Subclass code
    V25TER, // Protocol code
    0, // Interface string index

    /* CDC Class-Specific Descriptors */
    sizeof (USB_CDC_HEADER_FN_DSC),
    CS_INTERFACE,
    DSC_FN_HEADER,
    0x10, 0x01,

    sizeof (USB_CDC_ACM_FN_DSC),
    CS_INTERFACE,
    DSC_FN_ACM,
    USB_CDC_ACM_FN_DSC_VAL,

    sizeof (USB_CDC_UNION_FN_DSC),
    CS_INTERFACE,
    DSC_FN_UNION,
    CDC_COMM_INTF_ID,
    CDC_DATA_INTF_ID,

    sizeof (USB_CDC_CALL_MGT_FN_DSC),
    CS_INTERFACE,
    DSC_FN_CALL_MGT,
    0x00,
    CDC_DATA_INTF_ID,

    /* Endpoint Descriptor */
    //sizeof(USB_EP_DSC),DSC_EP,_EP02_IN,_INT,CDC_INT_EP_SIZE,0x02,
    0x07, /*sizeof(USB_EP_DSC)*/
    USB_DESCRIPTOR_ENDPOINT, //Endpoint Descriptor
    _EP01_IN, //EndpointAddress
    _INTERRUPT, //Attributes
    0x0A, 0x00, //size
    0x02, //Interval

    /* Interface Descriptor */
    9, //sizeof(USB_INTF_DSC),   // Size of this descriptor in bytes
    USB_DESCRIPTOR_INTERFACE, // INTERFACE descriptor type
    1, // Interface Number
    0, // Alternate Setting Number
    2, // Number of endpoints in this intf
    DATA_INTF, // Class code
    0, // Subclass code
    NO_PROTOCOL, // Protocol code
    0, // Interface string index

    /* Endpoint Descriptor */
    //sizeof(USB_EP_DSC),DSC_EP,_EP03_OUT,_BULK,CDC_BULK_OUT_EP_SIZE,0x00,
    0x07, /*sizeof(USB_EP_DSC)*/
    USB_DESCRIPTOR_ENDPOINT, //Endpoint Descriptor
    _EP02_OUT, //EndpointAddress
    _BULK, //Attributes
    0x40, 0x00, //size
    0x00, //Interval

    /* Endpoint Descriptor */
    //sizeof(USB_EP_DSC),DSC_EP,_EP03_IN,_BULK,CDC_BULK_IN_EP_SIZE,0x00
    0x07, /*sizeof(USB_EP_DSC)*/
    USB_DESCRIPTOR_ENDPOINT, //Endpoint Descriptor
    _EP02_IN, //EndpointAddress
    _BULK, //Attributes
    0x40, 0x00, //size
    0x00, //Interval
};

//Language code string descriptor

const struct
{
    uint8_t bLength;
    uint8_t bDscType;
    uint16_t string[1];
}

sd000={
    sizeof (sd000), USB_DESCRIPTOR_STRING,
    {
        0x0409
    }
};

//Manufacturer string descriptor

const struct
{
    uint8_t bLength;
    uint8_t bDscType;
    uint16_t string[14];
}

sd001={
    sizeof (sd001), USB_DESCRIPTOR_STRING,
    {
        'R', 'P', ' ', 'E', 'l', 'e', 'c', 't', 'r', 'o', 'n', 'i', 'c', 's'
    }
};

//Product string descriptor

const struct
{
    uint8_t bLength;
    uint8_t bDscType;
    uint16_t string[7];
}

sd002={
    sizeof (sd002), USB_DESCRIPTOR_STRING,
    {
        'R', 'P', ' ', 'T', 'o', 'o', 'l'
    }
};

//Array of configuration descriptors
const uint8_t*const USB_CD_Ptr[]={
    (const uint8_t*const) &configDescriptor1
};

////Array of string descriptors
//const uint8_t*const USB_SD_Ptr[USB_NUM_STRING_DESCRIPTORS]={
//    (const uint8_t*const) &sd000,
//    (const uint8_t*const) &sd001,
//    (const uint8_t*const) &sd002
//};

//Serial number string descriptor.  Note: This should be unique for each unit 
//built on the assembly line.  Plugging in two units simultaneously with the 
//same serial number into a single machine can cause problems.  Additionally, not 
//all hosts support all character values in the serial number string.  The MSD 
//Bulk Only Transport (BOT) specs v1.0 restrict the serial number to consist only
//of ASCII characters "0" through "9" and capital letters "A" through "F".

struct
{
    uint8_t bLength;
    uint8_t bDscType;
    uint16_t string[12];
}

sd003={
    sizeof (sd003), USB_DESCRIPTOR_STRING,
    {
        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1'
    }
};

void USER_USB_Device_LoadUDID(void)
{
    uint32_t udID;
    uint8_t i;

    udID=UDID1;

    for(i=0; i<8; i++)
    {
        sd003.string[i]=Bcd2Hex((uint8_t) (udID&0xF));
        udID>>=4;
    }

    udID=UDID2;

    for(i=0; i<4; i++)
    {
        sd003.string[8+i]=Bcd2Hex((uint8_t) (udID&0xF));
        udID>>=4;
    }
}

//Array of string descriptors
const uint8_t*const USB_SD_Ptr[]={
    (const uint8_t*const) &sd000,
    (const uint8_t*const) &sd001,
    (const uint8_t*const) &sd002,
    (const uint8_t*const) &sd003
};

#endif
